#Tryhackme Blogging Experience (29 July 2021)

This entry is for the Kenobi room.

##<-- Enumeration Stage -->

Using nmap with the -p- is not advisable here. Mainly because the question asking for the number of ports open do not match with the end result
of a nmap command with the

-A
-p-

flags.

The likely reason (my thoughts at the moment of writing this, could be completely wrong) being that the ports that were discovered exist way 
deeper than the first 1000 ports. These ports also happen to be for the Samba shares connected to the port 445.

Instad, 'nmap ip -vvv' is sufficient and even that is used in the hints.


##<-- Gaining access into ProFTpd -->

define ProFTpd: an open source FTP server.

Using netcat to connect to the machine.
Simply type nc <ip> <port>. Took more than time than it should to remember how to use.
The result: discover the version of ProFTpd the server runs.

Searchsploit is used here to find out available exploits for the proftpd version.

At this point, I was stuck at how to use the exploit for the Proftpd version. I started referring to John Hammond's walkthrough to actually understand how this all worked. https://youtu.be/60_g_hBVLbg

After learning how to use searchsploit -x and John Hammond's explanation, the exploit basically simply used commands available in the ProFtpd server to copy some files.
I thought something more confusing was happening but it was quite straightforward.

I also learned to use the 'export' command to set values to a variable ip so that I do not have to keep re-typing an ip address.

The gist of this exploit is that Proftpd had an exploit where any user - even unauthenticated ones - could run SITE CPFR (site copy from) and SITE CPTO (copy to) to copy files.
A var diretory was discovered from the enumeration strages and a log.txt file was discovered. This log detailed the generation of an ssh private/public key.

Afterwards, this key simply needed to be copied into the local machine. //completely wrong
Above was before I actually attempted the copying. What actually happens is that the file shold be copied into a smb directory that was discovered.
In this case, it's the /var. My mistake was that assuming SITE CPTO will copy into my own machine instead of the smb share. 
This explained why I was unable to find the file in my local machine despite copying multiple times.

After the file has been copied, it should be discoverable with smbclient. //completely 
/var was not an smb share, it was an NFS share. Meaning, it needed to be mounted on the local machine first.

```
nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.10.244.147
PORT    STATE SERVICE
111/tcp open  rpcbind
| nfs-showmount: 
|_  /var *

```
Studying back the NFS room can be helpful here.
At this point, it simply involved mounting the NFS share locally, cd into there and cp the id_rsa to the local machine.
ssh -i id_rsa user@ip can be used to connect to the machine which has the flag in the user.txt file.


##<-- Privilege Escalation with Path Variable Manipulation -->
find / -perm -u=s -type f 2>/dev/null

The command above should list files with SUID bit set. 
The Tryhackme question asks to identify any particularly strange file. With my current knowledge, I have zero clue on how to determine this.

John Hammond does mention that it would require experience to identify something abnormal OR simply compare the result of the find command to a local machine's which is what I attempted. Unfortunately, the command does not run on my Kali VM so I will need to refer to the menu.

Apparently running binaries doesn't require a '.' in the beginning. Unsure of how this actually works. Thought it'd require something like ./usr/bin/menu but instead I can forego the '.'.

Strings can be used as so:
strings file_directory

The /usr/bin/menu is an abnormal file due to SUID being set apparently. Running strings lets you see human readable text. The contents showed 'curl' being used and it does not refer to the full path for curl.

Due to the above reason, it would be possible to have the curl to refer to another file to allow privilege escalation and obtain a shell.

Trying out John Hammond's method did not workout for reasons that is a bit beyond me except that the curl resulted in "localhost: no such file or directory" which probably has something to do with the source code of the /usr/bin/menu having localhost included.

Following Tryhackme's command list does work after multiple attempts. This may be due to me not being familiar with how $PATH works exactly but after resetting the $PATH multiple times, it ended up working.

Once that is done, based on my understanding what should happen is running /usr/bin/menu will use a copied version of /bin/sh that is renamed as 'curl' that is on the default directory. As /usr/bin/menu calls for 'curl' but not specfically the actual/ABSOLUTE PATH of 'curl' , it instead actually runs /bin/sh with SUID set giving root shell access.

John Hammond showed a different method to this where it escalated the account to root instead of giving another shell by copying the /bin/bash with a -p flag instead of /bin/sh. 

This room turned out to be more complicated than I thought.

Reading some writeups from here https://noxious.tech/posts/Kenobi/
The author mentioned that this attack is known as a Path Hijacking attack.

##<-- Post Room Completion Re-attempt -->

For this attack to consistently work, it needs a better understanding of how $PATH works. John Hammond's method would not work when I overlooked this/less understood it.

Since I copied the /bin/sh file over to default directory, the /usr/bin/menu will not use the /bin/sh that was renamed to 'curl' at the default directory BECAUSE the $PATH was set to /tmp as the first priority to check. This mixup is because I referred to John Hammond's while also mixing it up with Tryhackme's instruction.

Essentially, for this privilege escalation to properly work, I need to copy /bin/sh to a directory that allowed WRITE. It can be /tmp or anything but for this example, let's go with /tmp.

Once it's copied into /tmp, I need to set permission so that it can be executed with chmod 777 filename or chmod +x filename.

I need to add /tmp - since that's where I copied the /bin/sh to be used as 'curl' - to $PATH with export PATH=/tmp:$PATH. This adds the /tmp to the $PATH variable so that when 'curl' is used, it prioritizes the 'curl' in /tmp instead of whatever other default directory it is originally located in.

Finally, that should give a root shell.



##<-- New commands/programs used -->

smbclient: A program to connect to the smb server as a client.  Seems to work similar to something like telnet or ftp. Used to connect to the discovered smb shares from enumeration.

smbget: Works similar like wget except to download file in an smb server. -R flag enables recursive download. Allows immediately downloading content of the smb server.

nmap smb-enum-shares, smb-enum-users.nse scripts: enumerate the smb shares attached to the target IP. The results of using this script is the reveal of the smb shares
which were the ports I discovered with the -p- flag enabled.

nmap nfs-ls, nfs-statfs nfs-showmount: shows an NFS mounted folder. The result here is a /var directory. This port uses the rpcbind service. Not very familiar with rpcbind.

Going off memory, rpcbind converts any rpc calls into a form that can be understood.
Tryhackme's explanation: converts remote call procedures (RPC) program number into universal addresses. When an RPC service starts,
it tells rpcbind the address at which it is listening and any RPC program number to be served.

searchsploit proftpd version: determine available exploits which references the exploit-db website.

searchsploit -x <file-path>: see details of the exploit in console

SITE CPFR directory
SITE CPTO directory

strings file_directory: searches for human readable text in the file

On yesteryday's issue with the wget, it is apparently because I downloaded the page not the actual bash file. Makes sense.